// "Точка обмена" (Exchange): 
//		может быть пустая. Это позволяет точно указать, в какую очередь
// 		должно пойти сообщение. В этом случае имя очереди указываем в routing_key (ключ маршрутизации)
//
// "Цикличность маршрутизации":
//		могут работать параллельно два задания. Если одно задание занято, то 
// 		сообщение получит другое задание    
//
// "Подтверждение получения сообщения" (message acknoledgment):
// 		Если одно задание завершилось с ошибкой, то сообщение будет потеряно, если 
// 		не пользоваться настройкой "Подтверждения получения сообщения", т.к. без настройки
// 		при отправке сообщения "получателю" rmq сразу же удалет его из очереди.
// 		Чтобы сообщение не удалялось нужно проверить, что параметр auto_ack = False (если это не так, то установить)
// 		По умолчанию параметр стоит False (В методе BasicConsume())
// 		Если другой "получатель" параллельно работает, то сообщение будет отправлено ему.
// 		По умолчанию выделено 30 минут на ожидание подтверждения получения (может быть изменено в настройках)
//
// "Долговечность сообщения" (Message Durability):
//		Если RMQ выключается или падает, все очереди и сообщения теряются,
// 		если не установить настройку "durable" на очереди и на сообщения.
// 		При установленной галке, что бы не случилось с RMQ сообщение все равно будет "жить". (quenedeclare(имяочереди, durable = Истина))
//		 *Если ранее объявляли очередь с признаком "Долговечности" = Ложь, 
//		то будет ошибка при объявлении очереди с тем же именем и признаком "долговечности" = Истина
// 		Объявим теперь сообщения "постоянными" (Persistent), чтобы сбой RMQ на них не повлиял. 
//		Для этого установим delivery_mode = Persistent (в basic_publish)  
//
// "Справедливая нагрузка" (Fair Dispatch - дословно "честная отправка"):
// 		Если одно задание постоянно занято (обрабатывает тяжелые сообщения), 
// 		то другое почти не будет выполнять никакой работы без особых настроек. 
// 		Потому что RMQ Не знает о состоянии заданий и будет равномерно отправлять сообщения.
// 		RMW не смотрит на число подтвержденных (an ack) сообщений. 
// 		Для исключения такой ситуации можно использовать метод канала "basic_ops" с настройкой 
//		"prefetch_count" = 1 
// 		Он использует протокол basic.qos для того, чтобы сказать RMQ не давать заданию 
//		более одного сообщения за раз.
// 		Другими словами не отправлять заданию сообщение, пока оно не отправит 
//		"подтверждение получения". В случае, если задание №1 занято и пока не отправило 
//		подтверждение, rmq отправит сообщение другому заданию.
